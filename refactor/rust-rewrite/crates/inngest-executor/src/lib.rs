use async_trait::async_trait;
use chrono::Utc;
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use uuid::Uuid;

use inngest_core::{Edge, Function, RunStatus, StateId, TrackedEvent};
use inngest_queue::{QueueError, QueueItem};
use inngest_state::{RunMetadata, StateManager};

pub mod consumer;

pub use consumer::*;

// TODO: Implement these modules
// pub mod http_executor;
// pub mod lifecycle;
// pub mod retry;

/// Request to schedule a function execution
#[derive(Debug, Clone)]
pub struct ScheduleRequest {
    pub workspace_id: Uuid,
    pub app_id: Uuid,
    pub function: Function,
    pub events: Vec<TrackedEvent>,
    pub idempotency_key: Option<String>,
    pub account_id: Uuid,
}

/// Response from function driver execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DriverResponse {
    /// Execution output data
    pub output: Option<serde_json::Value>,
    /// Error information if execution failed
    pub error: Option<String>,
    /// Whether to retry on failure
    pub no_retry: bool,
    /// Generated opcodes for next steps
    pub generator: Vec<GeneratorOpcode>,
    /// Additional metadata
    pub metadata: Option<serde_json::Value>,
}

impl DriverResponse {
    /// Check if this represents a function result (final output)
    pub fn is_function_result(&self) -> bool {
        self.generator.is_empty()
    }
}

/// Opcode generated by function execution to define next steps
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeneratorOpcode {
    /// Opcode identifier
    pub id: String,
    /// Opcode operation type
    pub op: OpcodeType,
    /// Opcode name/display name
    pub name: Option<String>,
    /// Opcode data
    pub data: Option<serde_json::Value>,
}

/// Types of opcodes that can be generated
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OpcodeType {
    /// Execute a step
    Step,
    /// Sleep for a duration
    Sleep,
    /// Wait for an event
    WaitForEvent,
    /// Invoke another function
    InvokeFunction,
    /// Parallel execution
    Parallel,
    /// No operation (function complete)
    None,
}

/// Lifecycle event listener for execution events
#[async_trait]
pub trait LifecycleListener: Send + Sync {
    /// Called when a function starts
    async fn on_function_started(
        &self,
        metadata: &RunMetadata,
        item: &QueueItem,
        events: &[serde_json::Value],
    );

    /// Called when a function finishes (success or failure)
    async fn on_function_finished(
        &self,
        metadata: &RunMetadata,
        item: &QueueItem,
        events: &[serde_json::Value],
        response: &DriverResponse,
    );

    /// Called when a step starts
    async fn on_step_started(&self, metadata: &RunMetadata, item: &QueueItem, edge: &Edge);

    /// Called when a step finishes
    async fn on_step_finished(
        &self,
        metadata: &RunMetadata,
        item: &QueueItem,
        edge: &Edge,
        response: &DriverResponse,
        error: Option<&ExecutorError>,
    );
}

/// Executor error types
#[derive(Debug, thiserror::Error)]
pub enum ExecutorError {
    #[error("State error: {0}")]
    State(#[from] inngest_state::StateError),

    #[error("Queue error: {0}")]
    Queue(#[from] QueueError),

    #[error("HTTP request failed: {0}")]
    Http(#[from] reqwest::Error),

    #[error("Function not found: {id}")]
    FunctionNotFound { id: Uuid },

    #[error("Function debounced")]
    FunctionDebounced,

    #[error("Function skipped")]
    FunctionSkipped,

    #[error("Function skipped due to idempotency")]
    FunctionSkippedIdempotency,

    #[error("Step limit exceeded: {limit}")]
    StepLimitExceeded { limit: usize },

    #[error("State size limit exceeded: {limit}")]
    StateSizeLimitExceeded { limit: usize },

    #[error("Execution timeout")]
    ExecutionTimeout,

    #[error("Invalid response from function")]
    InvalidResponse,

    #[error("Internal error: {0}")]
    Internal(String),
}

/// Main executor trait for function execution
#[async_trait]
pub trait Executor: Send + Sync {
    /// Schedule a function for execution
    async fn schedule(
        &self,
        request: ScheduleRequest,
    ) -> Result<Option<RunMetadata>, ExecutorError>;

    /// Execute a specific step
    async fn execute(
        &self,
        id: StateId,
        item: QueueItem,
        edge: Edge,
    ) -> Result<DriverResponse, ExecutorError>;

    /// Add lifecycle listener
    fn add_lifecycle_listener(&mut self, listener: Box<dyn LifecycleListener>);

    /// Set step limit function
    fn set_step_limit_fn(&mut self, f: Box<dyn Fn(StateId) -> usize + Send + Sync>);

    /// Set state size limit function
    fn set_state_size_limit_fn(&mut self, f: Box<dyn Fn(StateId) -> usize + Send + Sync>);
}

/// HTTP-based function executor with real execution capabilities
pub struct HttpExecutor {
    state_manager: Arc<dyn StateManager>,
    http_client: reqwest::Client,
    step_limit_fn: Option<Box<dyn Fn(StateId) -> usize + Send + Sync>>,
    state_size_limit_fn: Option<Box<dyn Fn(StateId) -> usize + Send + Sync>>,
    lifecycle_listeners: Vec<Box<dyn LifecycleListener>>,
    base_url: String,
    timeout: std::time::Duration,
}

impl HttpExecutor {
    pub fn new(state_manager: Box<dyn StateManager>, base_url: String) -> Self {
        Self {
            state_manager: Arc::from(state_manager),
            http_client: reqwest::Client::builder()
                .timeout(std::time::Duration::from_secs(30))
                .build()
                .expect("Failed to create HTTP client"),
            step_limit_fn: None,
            state_size_limit_fn: None,
            lifecycle_listeners: Vec::new(),
            base_url,
            timeout: std::time::Duration::from_secs(30),
        }
    }

    pub fn new_with_arc(state_manager: Arc<dyn StateManager>, base_url: String) -> Self {
        Self {
            state_manager,
            http_client: reqwest::Client::builder()
                .timeout(std::time::Duration::from_secs(30))
                .build()
                .expect("Failed to create HTTP client"),
            step_limit_fn: None,
            state_size_limit_fn: None,
            lifecycle_listeners: Vec::new(),
            base_url,
            timeout: std::time::Duration::from_secs(30),
        }
    }

    /// Create HTTP request payload in Inngest format
    fn create_inngest_payload(
        &self,
        function: &Function,
        item: &QueueItem,
        events: &[TrackedEvent],
    ) -> serde_json::Value {
        let mut event_data = serde_json::Map::new();

        // Add events in the format expected by Inngest SDK
        if let Some(first_event) = events.first() {
            event_data.insert(
                "name".to_string(),
                serde_json::Value::String(first_event.event.name.clone()),
            );
            event_data.insert("data".to_string(), first_event.event.data.clone());
            event_data.insert(
                "id".to_string(),
                serde_json::Value::String(
                    first_event
                        .event
                        .id
                        .map(|id| id.to_string())
                        .unwrap_or_else(|| Uuid::new_v4().to_string()),
                ),
            );
            event_data.insert(
                "ts".to_string(),
                serde_json::Value::Number(serde_json::Number::from(
                    first_event
                        .event
                        .ts
                        .map(|ts| ts.timestamp_millis())
                        .unwrap_or_else(|| chrono::Utc::now().timestamp_millis()),
                )),
            );
        }

        serde_json::json!({
            "event": event_data,
            "events": events.iter().map(|te| {
                serde_json::json!({
                    "name": te.event.name,
                    "data": te.event.data,
                    "id": te.event.id.map(|id| id.to_string()).unwrap_or_else(|| Uuid::new_v4().to_string()),
                    "ts": te.event.ts.map(|ts| ts.timestamp_millis()).unwrap_or_else(|| chrono::Utc::now().timestamp_millis())
                })
            }).collect::<Vec<_>>(),
            "ctx": {
                "function_id": function.config.id,
                "run_id": item.id.to_string(),
                "attempt": 1,
                "env": "development"
            },
            "steps": {},
            "use_api": false
        })
    }

    /// Execute actual HTTP request to user function
    async fn invoke_function(
        &self,
        function: &Function,
        payload: serde_json::Value,
    ) -> Result<DriverResponse, ExecutorError> {
        // Construct function URL - typically the base_url + function endpoint
        let function_url = format!("{}/api/inngest", self.base_url);

        tracing::info!(
            "Invoking function {} at URL: {}",
            function.config.name,
            function_url
        );

        let request = self
            .http_client
            .post(&function_url)
            .header("Content-Type", "application/json")
            .header("User-Agent", "Inngest/Rust-1.0")
            .header("X-Inngest-Framework", "rust")
            .json(&payload)
            .timeout(self.timeout);

        let start_time = std::time::Instant::now();

        match request.send().await {
            Ok(response) => {
                let duration = start_time.elapsed();
                let status = response.status();

                tracing::info!(
                    "Function {} responded with status {} in {:?}",
                    function.config.name,
                    status,
                    duration
                );

                if status.is_success() {
                    let response_text =
                        response.text().await.map_err(|e| ExecutorError::Http(e))?;

                    // Try to parse JSON response
                    match serde_json::from_str::<serde_json::Value>(&response_text) {
                        Ok(json_response) => {
                            Ok(DriverResponse {
                                output: Some(json_response.clone()),
                                error: None,
                                no_retry: false,
                                generator: vec![], // No steps for now
                                metadata: Some(serde_json::json!({
                                    "duration_ms": duration.as_millis(),
                                    "status_code": status.as_u16()
                                })),
                            })
                        }
                        Err(_) => {
                            // Non-JSON response, treat as text
                            Ok(DriverResponse {
                                output: Some(serde_json::Value::String(response_text)),
                                error: None,
                                no_retry: false,
                                generator: vec![],
                                metadata: Some(serde_json::json!({
                                    "duration_ms": duration.as_millis(),
                                    "status_code": status.as_u16()
                                })),
                            })
                        }
                    }
                } else {
                    let error_text = response
                        .text()
                        .await
                        .unwrap_or_else(|_| format!("HTTP {}", status));

                    // Determine if this should be retried based on status code
                    let _no_retry = matches!(status.as_u16(), 400..=499);

                    Err(ExecutorError::Internal(format!(
                        "HTTP {}: {}",
                        status, error_text
                    )))
                }
            }
            Err(e) => {
                tracing::error!("Failed to invoke function {}: {}", function.config.name, e);
                Err(ExecutorError::Http(e))
            }
        }
    }
}

#[async_trait]
impl Executor for HttpExecutor {
    async fn schedule(
        &self,
        request: ScheduleRequest,
    ) -> Result<Option<RunMetadata>, ExecutorError> {
        tracing::info!(
            "Scheduling function: {} for workspace: {}",
            request.function.config.name,
            request.workspace_id
        );

        // Create run metadata
        let state_id = StateId::new();

        let metadata = RunMetadata {
            id: state_id,
            function_id: request.function.id,
            function_version: request.function.version,
            status: RunStatus::Running,
            started_at: Some(Utc::now()),
            ended_at: None,
            event_ids: request.events.iter().map(|e| e.internal_id).collect(),
            idempotency_key: request.idempotency_key,
            batch_id: None,
        };

        // Create state for this run
        self.state_manager
            .create_run(&metadata)
            .await
            .map_err(|e| ExecutorError::State(e))?;

        tracing::info!(
            "Successfully scheduled function {} with run_id: {}",
            request.function.config.name,
            metadata.id.to_string()
        );

        Ok(Some(metadata))
    }

    async fn execute(
        &self,
        id: StateId,
        item: QueueItem,
        _edge: Edge,
    ) -> Result<DriverResponse, ExecutorError> {
        tracing::info!(
            "Executing function step for run_id: {} item_id: {}",
            id.to_string(),
            item.id.to_string()
        );

        // For now, we'll use dummy function execution since we don't have function loading yet
        // Create a dummy function representation
        let function = Function {
            id: Uuid::new_v4(), // Use item data to identify function
            config: inngest_core::FunctionConfig {
                id: format!("function-{}", item.id),
                name: format!("function-{}", item.id),
                triggers: vec![], // Would be loaded from storage
                concurrency: None,
                rate_limit: None,
                batch: None,
                retry: None,
                steps: vec![],
            },
            version: 1,
            app_id: Uuid::new_v4(),
            slug: format!("function-{}", item.id),
        };

        // Create events from queue item data
        let events = vec![TrackedEvent {
            event: inngest_core::Event {
                id: Some(Uuid::new_v4()), // Convert ULID to UUID or generate new one
                name: "execution.requested".to_string(),
                data: serde_json::json!({"queue_item_id": item.id.to_string()}),
                user: None,
                version: Some("2023-05-15".to_string()),
                ts: Some(Utc::now()),
            },
            internal_id: Uuid::new_v4(),
            workspace_id: Uuid::new_v4(), // Would come from context
            received_at: Utc::now(),
        }];

        // Create Inngest-compatible payload
        let payload = self.create_inngest_payload(&function, &item, &events);

        // Execute the actual function
        let result = self.invoke_function(&function, payload).await;

        // For now, we'll just log the result and return it
        // In a full implementation, we would update state in the StateManager
        match &result {
            Ok(response) => {
                tracing::info!(
                    "Function execution completed for item_id: {} with output: {:?}",
                    item.id,
                    response.output
                );
            }
            Err(e) => {
                tracing::error!(
                    "Function execution failed for item_id: {} with error: {}",
                    item.id,
                    e
                );
            }
        }

        result
    }

    fn add_lifecycle_listener(&mut self, listener: Box<dyn LifecycleListener>) {
        self.lifecycle_listeners.push(listener);
    }

    fn set_step_limit_fn(&mut self, f: Box<dyn Fn(StateId) -> usize + Send + Sync>) {
        self.step_limit_fn = Some(f);
    }

    fn set_state_size_limit_fn(&mut self, f: Box<dyn Fn(StateId) -> usize + Send + Sync>) {
        self.state_size_limit_fn = Some(f);
    }
}
